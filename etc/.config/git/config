# Local/private config goes in the include
[include]
  path = ~/.config/git/credentials

[core]
  mergeoptions = --no-edit
  excludesfile = ~/.config/git/ignore

[init]
	defaultBranch = main

[pull]
	ff = only

[push]
  default = simple

[rebase]
  # Git message starts with !fixup
  autosquash = true

[rerere]
  enabled = true

[protocol]
  # https://github.blog/changelog/2018-11-08-git-protocol-v2-support/
	version = 2

[alias]
  # List authors
  authors = shortlog -sn
  # Backup the current branch
  backup-branch = !git branch "backup/$(git branch-name)"
  # Shortcut for `git branch`
  br = branch
  # Delete a branch
  brd = branch -d
  # Show local branches with details
  branches = branch -vv
  # Show the current branch name
  branch-name = !git rev-parse --abbrev-ref HEAD
  # List configuration
  cf = config --list
  # Commit the staged changes
  ci = commit
  # Commit ammend
  cia = !git commit --amend
  # Commit ammend with no edit
  cian = !git commit --amend --no-edit
  # Commit fixup (git commit --fixup :/second)
  cif = !git commit --fixup
  # Commit ammend with no edit
  cim = !git commit -m
  # Commit then squashbase
  cis = !git commit -m 'chore: squash' && git squash
  # Commit then squashbase
  cisb = !git commit -m 'chore: squash' && git squashbase
  # Reset and clean the repo dir
  clean-pristine = !git reset --hard && git clean -fdX
  # Clones recursively
  cloner = clone --recursive
  # Shortcut for `git checkout`
  co = checkout
  # Shortcut for `git checkout -b`
  cob = checkout -b
  # Checkout default branch
  cod = !git checkout $(git default-branch)
  # Display the number of commits
  count = "!f() { compareBranch=${1-`git default-branch`}; git rev-list --count HEAD ^$compareBranch; }; f"
  # Cherry pick commits
  cp = cherry-pick
  # Cherry pick with sign off line
  cps = cherry-pick -s
  # Alias for check out default branch
  cm = cod
  # Get default branch for repo
  default-branch = !git symbolic-ref --short HEAD
  # Use fuzzy finder for diff
  df = !git-fuzzy-diff
  # Show changes that have been staged
  diffc = diff --cached
  # Shows the files changed between
  diffn = diff --name-only
  # Shows the files changed between
  diffs = diff --stat
  # Fetch and prune all branches that do not exist in remote
  fetchp = fetch -p
  # Display a log of incoming changes
  in = !git wtf HEAD..HEAD@{u}
  # Delete all merged branches but default
  kill-branches = !git branch --merged | grep -v '\\b`git default-branch`\\b' | xargs git branch -d
  # List branches
  lb = !git reflog show --pretty=format:'%gs ~ %gd' --date=relative | grep 'checkout:' | grep -oE '[^ ]+ ~ .*' | awk -F~ '!seen[$1]++' | head -n 10 | awk -F' ~ HEAD@{' '{printf(\"  \\033[33m%s: \\033[36m %s\\033[0m\\n\", substr($2, 1, length($2)-1), $1)}'
  # Display the last tag info
  lasttag = describe --tags --abbrev=0
  # List all files
  lsf = ls-files
  # Show remote
  ls-merged = !git branch -r --merged | grep -v `git default-branch`
  # Show log (one commit per line)
  logl = log --oneline
  # Show log with details (one commit per line)
  logp = log --pretty=format:"%C(auto,yellow)%h%C(auto)%d\\ %C(auto,reset)%s\\ \\ [%C(auto,blue)%cn%C(auto,reset),\\ %C(auto,cyan)%ar%C(auto,reset)]"
  # Show log with file stats
  logs = log --stat --pretty=short --graph
  # Show log graph (one commit per line)
  logv = log --oneline --graph --decorate
  # Create a new branch `git [newb] [proj [branchName]`
  newf = "!f() { ticketNum=$1; branchName=$2; git checkout -b \"feature/${ticketNum}-${branchName}\"; }; f"
  # Do not auto commit in order to inspect the result
  nomerge = --no-commit --no-ff $@
  # Stage our files during a merge
  ours = "!f() { git checkout --ours -- $@ && git add -- $@; }; f"
  # Display a log of outgoing changes
  out = !git wtf HEAD@{u}..HEAD
  # Pull submodules and all recursively
  pulla = !git pull && git submodule update --init --recursive && git submodule update --recursive
  # Push force no-verify
  pushf = push --force-with-lease --no-verify
  # Push upstream
  pushu = !git push -u origin `git branch-name`
  # Rebase
  rb = rebase
  # Rebase default branch (main, develop, etc)
  rbb = "!f() { branchName=$(git default-branch); git squashbase -i $branchName; }; f"
  # Shortcut for `git rebase --continue`
  rbc = rebase --continue
  # Shortcut for `git rebase --interactive`
  rbi = rebase --interactive
  # Reset to origin/[default-branch] (e.g. main)
  reset-to-default = !git fetch origin && git reset --hard origin/`git default-branch`
  # Reset to origin/[current-branch]
  reset-to-origin = !git fetch --all && git reset --hard origin/`git branch-name`
  # Switch to the default branch
  sd = !git switch $(git default-branch)
  # squash up to
  squash = !git rebase -i HEAD~${1:-2}
  # Squash up to default branch (main, develop, etc)
  squashbase = "!f() { defaultBranch=`git default-branch`; branchName=${1-$defaultBranch}; commitCount=`git count $branchName`; git rebase -i HEAD~$commitCount; }; f"
  # Show current branch status with short format
  st = status -sb
  # Show current branch status with untracked files
  stu = status --untracked-files
  # Switch branches
  sw = switch
  # Pull & push the current branch
  sync = !git pull && git push
  # Update a fork
  sync-fork = !git fetch upstream && git checkout `git default branch` && git merge upstream/master
  # Stage the incoming changes
  theirs = "!f() { git checkout --theirs -- $@ && git add -- $@; }; f"
  # List differences from yesterday
  today = diff @{yesterday}.. --stat
  # Reset to head
  uncommit = reset HEAD^
  # Unstage all files
  unstage = reset HEAD
  # Display word diff
  wdiff = diff --word-diff=color
  # Show word diff objects
  wshow = show --word-diff=color
  # Git worktree
  wt = worktree
  # Display a pretty change log
  wtf = log --pretty=format:"%C(auto,yellow)%h%C(auto)%d%C(auto,reset)\\ by\\ %C(auto,blue)%cn%C(auto,reset),\\ %C(auto,cyan)%ar%C(auto,reset)%n\\ %s%n" --stat
  # -- Advanced (wip) ---
  # autotrack = "!x() { b=`git symbolic-ref -q --short HEAD` && git branch -u \"origin/$b\" || echo \"error: not a branch\"; }; x"
  # comerge = "!x() { target=`git symbolic-ref HEAD`; git co $1; git merge $target; }; x"
  # Display the number of commits
  # count = "!f() { defaultBranch=$(git default-branch); compareBranch=${1:-$defaultBranch}; git rev-list --count HEAD ^$compareBranch; }; f"
  # delete-remote-merged = git branch -r --merged | grep -v `git default-branch` | sed 's/origin\///' | xargs -n 1 git push --delete origin
  # Show changed files between commits
  # difff = "!f() { a=$(git branch-name); b=$(git default-branch); git diff --name-only ${1:-$a} $(git merge-base ${1:-$a} ${2:-$b}); }; f"
  # Pull default branch and rebase current branch on top
  # pullbase = "!f() { defaultBranch=$(git default-branch); branchName=${1-$defaultBranch}; git checkout $branchName && git pull && git checkout - && git rebase -i $branchName; }; f"
  # Update the remote
  # rup = !git remote update `git rev-parse --symbolic-full-name HEAD@{u}|cut -d/ -f3`
  # unassume = update-index --no-assume-unchanged
  # unassumeall = !git assumed | xargs git update-index --no-assume-unchanged

# Include additional local/private config settings
[include]
  path = ~/.config/git/config.local
