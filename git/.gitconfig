[core]
	excludesfile = ~/.dotfiles/git/.gitignore
  mergeoptions = --no-edit

[push]
  default = simple

[alias]
  addpr = "!f() { git fetch origin pull/$1/head:pr/$1; }; f"
  assume = update-index --assume-unchanged
  assumed = "!git ls-files -v | grep ^h | cut -c 3-"
  authors = shortlog -sn
  autotrack = "!x() { b=`git symbolic-ref -q --short HEAD` && git branch -u \"origin/$b\" || echo \"error: not a branch\"; }; x"
  # Shortcut for `git branch`
  br = branch
  # Show local branches with details
  branches = branch -vv
  # Rename the branch
  branch-name = !git rev-parse --abbrev-ref HEAD
  # Commit the staged changes
  ci = commit
  # Shortcut for `git checkout`
  co = checkout
  comerge = "!x() { target=`git symbolic-ref HEAD`; git co $1; git merge $target; }; x"
  cp = cherry-pick
  cps = cherry-pick -s
  count = "!f() { compareBranch=${1-master}; git rev-list --count HEAD ^$compareBranch; }; f"
  # Delete merged branches
  # delete-remote-merged = git branch -r --merged | grep -v master | sed 's/origin\///' | xargs -n 1 git push --delete origin
  # Show changes that have been staged
  diffc = diff --cached
  # Show the difference from master
  # diffm = diff master...`!git branch-name`
  # Fetch and prune all branches that do not exist in remote
  fetchp = fetch -p
  # Show log with details
  gflog = log -p --cc --graph --decorate
  # Show log as tree visually (one commit per line)
  gslog = log --oneline --graph --decorate
  # Show log (one commit per line)
  glog = log --graph --pretty=format:"%C(auto,yellow)%h%C(auto)%d\\ %C(auto,reset)%s\\ \\ [%C(auto,blue)%cn%C(auto,reset),\\ %C(auto,cyan)%ar%C(auto,reset)]"
  in = !git wtf HEAD..HEAD@{u}
  killbranches = !git branch | grep -v '\\bmaster\\b' | xargs git branch -d 2> /dev/null
  lasttag = describe --tags --abbrev=0
  # List all files
  ls = ls-files
  # Show remote
  ls-merged = `git branch -r --merged | grep -v master`
  # Ammend the last commit
  meh = commit --amend
  # Create a new branch `git [newb] [proj [branchName]`
  newb = "!f() { proj=$1 ticketNum=$2; branchName=$3; git checkout -b \"${proj^^j}-${ticketNum}-${branchName}\"; }; f"
  nomerge = --no-commit --no-ff $@
  # Stage our files during a merge
  ours = "!f() { git checkout --ours -- $@ && git add -- $@; }; f"
  out = !git wtf HEAD@{u}..HEAD
  # Pull master and rebase current branch on top
  pullbase = "!f() { branchName=${1-master}; git checkout $branchName && git pull && git checkout - && git rebase -i $branchName; }; f"
  # Reset to origin/master
  reset-to-master = !git fetch origin; !git reset --hard origin/master
  rup = !git remote update `git rev-parse --symbolic-full-name HEAD@{u}|cut -d/ -f3`
  serve = daemon --verbose --export-all --base-path=.git --reuseaddr --strict-paths .git/
  serveall = daemon --verbose --export-all --base-path=. --reuseaddr .
  # Show log with details (one commit per line)
  slog = log --pretty=format:"%C(auto,yellow)%h%C(auto)%d\\ %C(auto,reset)%s\\ \\ [%C(auto,blue)%cn%C(auto,reset),\\ %C(auto,cyan)%ar%C(auto,reset)]"
  # Squash up to master
  squashbase = "!f() { branchName=${1-master}; commitCount=$(git count $branchName); git rebase -i HEAD~$commitCount; }; f"
  # Show current branch status with short format
  st = status -sb
  # Pull & push the current branch
  sync = !git pull && git push
  # Stage the incoming changes
  theirs = "!f() { git checkout --theirs -- $@ && git add -- $@; }; f"
  # List differences from yesterday
  today = diff @{yesterday}.. --stat
  unassume = update-index --no-assume-unchanged
  unassumeall = "!git assumed | xargs git update-index --no-assume-unchanged"
  unci = reset HEAD^
  uncommit = reset HEAD^
  # Unstage all files
  unstage = reset HEAD
  wdiff = diff --word-diff=color
  wshow = show --word-diff=color
  wtf = log --pretty=format:"%C(auto,yellow)%h%C(auto)%d%C(auto,reset)\\ by\\ %C(auto,blue)%cn%C(auto,reset),\\ %C(auto,cyan)%ar%C(auto,reset)%n\\ %s%n" --stat

[include]
  path = ~/.dotfiles/local/.gitconfig
